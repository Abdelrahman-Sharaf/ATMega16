/*****************************************************************************/
/* Title                 :   ADC_prog                                       */
/* Filename              :   ADC_prog.c                                     */
/* Author                :   Shaban Abdullah Awad                            */
/* Origin Date           :   Oct 13, 2021                                     */
/* Version               :   1.0.0                                           */
/* Compiler              :   mingw GCC                                       */
/* Target                :   ATmega16 , ATmega32                             */
/* Notes                 :   None                                            */
/*                                                                           */
/*****************************************************************************/

/****************************************************************************/
/******************************  INCLUDES  **********************************/
#include "E:\NTI\AVR\ATmeg16_Drivers\LIB\STD_TYPES.h"
#include "E:\NTI\AVR\ATmeg16_Drivers\LIB\errorStates.h"

#include "E:\NTI\AVR\ATmeg16_Drivers\MCAL\interrupt.h"
#include "E:\NTI\AVR\ATmeg16_Drivers\MCAL\GIE\GIE_interface.h"

#include "ADC_priv.h"
#include "ADC_Cnfg.h"

/**********************************************************************************/
/* Description     : Tow global arrays of pointers to hold the Addresses of       */
/*                   the functions and its arguments to use the in the            */
/*                   CallBack.                                                    */
/***********************************************************************************/
static volatile void (*ADC_pvidfunISRFunc)(void*)= NULL ;

static volatile void* ADC_pvidISRParameter=  NULL ;







ES_t ADC_enuInit(void)
{
	ES_t Local_enuErrorState = ES_NOK ;

	/*******************************************************************************/
	/*ADC Prescaler cases Handling.                                                */
	/*******************************************************************************/
	ADCSRA  &=~((ADC_MSK_BIT<<ADPS0)|(ADC_MSK_BIT<<ADPS1)|(ADC_MSK_BIT<<ADPS2));

#if      ADC_PRES   ==    PRES_2
	//Do nothing.

#elif    ADC_PRES   ==    PRES_4
	ADCSRA |=(ADC_MSK_BIT<<ADPS1);

#elif    ADC_PRES   ==    PRES_8
	ADCSRA |=(ADC_MSK_BIT<<ADPS0)|(ADC_MSK_BIT<<ADPS1);

#elif    ADC_PRES   ==    PRES_16
	ADCSRA |=(ADC_MSK_BIT<<ADPS2);

#elif    ADC_PRES   ==    PRES_32
	ADCSRA |=(ADC_MSK_BIT<<ADPS0)|(ADC_MSK_BIT<<ADPS2);

#elif    ADC_PRES   ==    PRES_64
	ADCSRA |=(ADC_MSK_BIT<<ADPS1)|(ADC_MSK_BIT<<ADPS2);

#elif    ADC_PRES   ==    PRES_128
	ADCSRA |=(ADC_MSK_BIT<<ADPS0)|(ADC_MSK_BIT<<ADPS1)|(ADC_MSK_BIT<<ADPS2);

#else

#error "Not valid ADC_PRES value!!."

#endif


	/*******************************************************************************/
	/*ADC Voltage Reference cases Handling.                                        */
	/*******************************************************************************/
	ADMUX  &=~((ADC_MSK_BIT<<REFS1)|(ADC_MSK_BIT<<REFS0));

#if      ADC_REF_VOLT   ==    AREF_REF
	//Do nothing.

#elif    ADC_REF_VOLT   ==    AVCC_REF
	ADMUX  |=(ADC_MSK_BIT<<REFS0);

#elif    ADC_REF_VOLT   ==    INTERNAL_AREF
	ADMUX  |=(ADC_MSK_BIT<<REFS1)|(ADC_MSK_BIT<<REFS0);

#else
#error "The ADC_REF_VOLT value that you Chosen is not Valid!!."

#endif


	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
ES_t ADC_enuStartConversion(void)
{
	ES_t Local_enuErrorState = ES_NOK ;

	ADCSRA |=(ADC_MSK_BIT<<ADSC);

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
ES_t ADC_enuPollingSys(u16* Cpy_pu8Value)
{
	ES_t Local_enuErrorState = ES_NOK ;


	while( !((ADCSRA>>ADIF)&ADC_MSK_BIT) );

	ADCSRA |=(ADC_MSK_BIT<<ADIF);

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
ES_t ADC_enuReadHighValue(u8* Cpy_pu8Value )
{
	ES_t Local_enuErrorState = ES_NOK ;

#if      ADC_ADJ   ==   RIGHT_ADJ
	*Cpy_pu8Value = GET_HIGH_BITS_RIGHT_ADJ  ;


#elif    ADC_ADJ   ==   LEFT_ADJ
	*Cpy_pu8Value = ADCH ;

#else
#error "The ADC_ADJ mode that you Chosen is not Valid!!."
#endif

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
ES_t ADC_enuRead(u16* Cpy_pu16Value )
{
	ES_t Local_enuErrorState = ES_NOK ;


#if      ADC_ADJ   ==   RIGHT_ADJ
	*Cpy_pu16Value  =  (u16)ADCL  ;
	*Cpy_pu16Value |= ((u16)ADCH<< 8 );


#elif    ADC_ADJ   ==   LEFT_ADJ
	*Cpy_pu16Value  =  ((u16)ADCL>>6)   ;
	*Cpy_pu16Value |=  ((u16)ADCH<<2)   ;

#else
#error "The ADC_ADJ mode that you Chosen is not Valid!!."
#endif




	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
ES_t ADC_enuSelectChannel(u8 Cpy_u8ChannelID )
{
	ES_t Local_enuErrorState = ES_NOK ;

	if( Cpy_u8ChannelID < CHANNEL_7 )
	{
		ADMUX &=~( (ADC_MSK_BIT<<MUX2)|(ADC_MSK_BIT<<MUX1)||(ADC_MSK_BIT<<MUX0)  );


		Local_enuErrorState = ES_OK ;
	}
	else
	{
		Local_enuErrorState = ES_OUT_OF_RANGE ;
	}

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
ES_t ADC_enuEnableTriggeringMode(u8 Cpy_u8TriggingSource)
{
	ES_t Local_enuErrorState = ES_NOK ;

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
ES_t ADC_enuDisableTriggeringMode(void)
{
	ES_t Local_enuErrorState = ES_NOK ;

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/

ES_t ADC_enuEnable(void)
{
	ES_t Local_enuErrorState = ES_NOK ;

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/

ES_t ADC_enuDisable(void)
{
	ES_t Local_enuErrorState = ES_NOK ;

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/


ES_t ADC_enuEnableInterruptMode(void)
{
	ES_t Local_enuErrorState = ES_NOK ;

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/

ES_t ADC_enuDisableInterruptMode(void)
{
	ES_t Local_enuErrorState = ES_NOK ;

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/



ES_t ADC_enuCallBack( void(*Cpy_pfunAppFunc)(void*) , void* Cpy_pvidAppPara)
{
	ES_t Local_enuErrorState = ES_NOK ;

	if( Cpy_pfunAppFunc != NULL )
	{
		ADC_pvidfunISRFunc   = Cpy_pfunAppFunc ;

		ADC_pvidISRParameter = Cpy_pvidAppPara ;

		Local_enuErrorState  = ES_OK ;
	}
	else
	{
		Local_enuErrorState = ES_NULL_POINTER  ;
	}
	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/


/*
 *
 *
 *
 *
 */



