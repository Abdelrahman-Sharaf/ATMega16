/*****************************************************************************/
/* Title                 :   ADC_prog                                       */
/* Filename              :   ADC_prog.c                                     */
/* Author                :   Shaban Abdullah Awad                            */
/* Origin Date           :   Oct 13, 2021                                     */
/* Version               :   1.0.0                                           */
/* Compiler              :   mingw GCC                                       */
/* Target                :   ATmega16 , ATmega32                             */
/* Notes                 :   None                                            */
/*                                                                           */
/*****************************************************************************/

/****************************************************************************/
/******************************  INCLUDES  **********************************/
#include "E:\NTI\AVR\ATmeg16_Drivers\LIB\STD_TYPES.h"
#include "E:\NTI\AVR\ATmeg16_Drivers\LIB\errorStates.h"

#include "E:\NTI\AVR\ATmeg16_Drivers\MCAL\interrupt.h"
#include "E:\NTI\AVR\ATmeg16_Drivers\MCAL\GIE\GIE_interface.h"

#include "ADC_priv.h"
#include "ADC_Cnfg.h"

/**********************************************************************************/
/* Description     : Tow global arrays of pointers to hold the Addresses of       */
/*                   the functions and its arguments to use the in the            */
/*                   CallBack.                                                    */
/***********************************************************************************/
static volatile void (*ADC_pvidfunISRFunc)(void*)= NULL ;

static volatile void* ADC_pvidISRParameter=  NULL ;







ES_t ADC_enuInit(void)
{
	ES_t Local_enuErrorState = ES_NOK ;


	/*******************************************************************************/
	/*ADC Voltage Reference cases Handling.                                        */
	/*******************************************************************************/
	ADMUX  &=~((ADC_MSK_BIT<<REFS1)|(ADC_MSK_BIT<<REFS0));

#if      ADC_REF_VOLT   ==    AREF_REF
	//Do nothing.

#elif    ADC_REF_VOLT   ==    AVCC_REF
	ADMUX  |=(ADC_MSK_BIT<<REFS0);

#elif    ADC_REF_VOLT   ==    INTERNAL_AREF
	ADMUX  |=(ADC_MSK_BIT<<REFS1)|(ADC_MSK_BIT<<REFS0);

#else
#error "The ADC_REF_VOLT value that you Chosen is not Valid!!."

#endif


	/****************************************************************************************/
	/*ADC Prescaler cases Handling and Right Presentation of the ADC result is Selected.    */
	/****************************************************************************************/

	ADCSRA  &=~((ADC_MSK_BIT<<ADPS0)|(ADC_MSK_BIT<<ADPS1)|(ADC_MSK_BIT<<ADPS2));

#if      ADC_PRES   ==    PRES_2
	//Do nothing.

#elif    ADC_PRES   ==    PRES_4
	ADCSRA |=(ADC_MSK_BIT<<ADPS1);

#elif    ADC_PRES   ==    PRES_8
	ADCSRA |=(ADC_MSK_BIT<<ADPS0)|(ADC_MSK_BIT<<ADPS1);

#elif    ADC_PRES   ==    PRES_16
	ADCSRA |=(ADC_MSK_BIT<<ADPS2);

#elif    ADC_PRES   ==    PRES_32
	ADCSRA |=(ADC_MSK_BIT<<ADPS0)|(ADC_MSK_BIT<<ADPS2);

#elif    ADC_PRES   ==    PRES_64
	ADCSRA |=(ADC_MSK_BIT<<ADPS1)|(ADC_MSK_BIT<<ADPS2);

#elif    ADC_PRES   ==    PRES_128
	ADCSRA |=(ADC_MSK_BIT<<ADPS0)|(ADC_MSK_BIT<<ADPS1)|(ADC_MSK_BIT<<ADPS2);

#else

#error "Not valid ADC_PRES value!!."

#endif


	/*******************************************************************************/
	/* Enable ADC .                                                                */
	/*******************************************************************************/
	ADCSRA |= (ADC_MSK_BIT<<ADEN);


	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
ES_t ADC_enuStartConversion(void)
{
	ES_t Local_enuErrorState = ES_NOK ;

	ADCSRA |=(ADC_MSK_BIT<<ADSC);

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
ES_t ADC_enuPollingSys(void)
{
	ES_t Local_enuErrorState = ES_NOK ;


	while( !((ADCSRA>>ADIF)&ADC_MSK_BIT) );

	ADCSRA |=(ADC_MSK_BIT<<ADIF);

	return Local_enuErrorState   ;
}//End of


/*********************************************************/
/*********************************************************/
ES_t ADC_enuRead(u16* Cpy_pu16Value )
{
	ES_t Local_enuErrorState = ES_NOK ;

	*Cpy_pu16Value = 0 ;

	*Cpy_pu16Value  =  (u16)ADCL  ;
	*Cpy_pu16Value |= ( ((u16)ADCH)<< 8 );


	return Local_enuErrorState   ;
}//End of

/*********************************************************/
/*********************************************************/
/*********************************************************/
ES_t ADC_enuSelectChannel(u8 Cpy_u8ChannelID )
{
	ES_t Local_enuErrorState = ES_NOK ;

	if( Cpy_u8ChannelID <= CHANNEL_4_2 )
	{
		ADMUX &=~( (ADC_MSK_BIT<<MUX4)|(ADC_MSK_BIT<<MUX3)|(ADC_MSK_BIT<<MUX2)|(ADC_MSK_BIT<<MUX1)|(ADC_MSK_BIT<<MUX0)  );

		ADMUX |= Cpy_u8ChannelID ;

		Local_enuErrorState = ES_OK ;
	}
	else
	{
		Local_enuErrorState = ES_OUT_OF_RANGE ;
	}

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
ES_t ADC_enuEnableTriggeringMode(u8 Cpy_u8TriggingSource)
{
	ES_t Local_enuErrorState = ES_NOK ;

	if( Cpy_u8TriggingSource <= EXTI1_CAP_EVNT )
	{
		//Disable auto triggering source.
		ADCSRA  &=~(ADC_MSK_BIT<<ADATE);

		SFIOR &=~( (ADC_MSK_BIT<<ADTS2) | ( ADC_MSK_BIT<<ADTS1 ) | (ADC_MSK_BIT<<ADTS0)   );

		switch( Cpy_u8TriggingSource )
		{
		case FREE_RUNNING :
			break;

		case ANALOG_COMPARATOR :
			SFIOR |=(ADC_MSK_BIT<<ADTS0) ;
			break;

		case EXTI0 :
			SFIOR |=(ADC_MSK_BIT<<ADTS1) ;
			break;

		case EXTI0_CTC :
			SFIOR |=(ADC_MSK_BIT<<ADTS0) ;
			SFIOR |=(ADC_MSK_BIT<<ADTS1) ;
			break;

		case EXTI0_OVF :
			SFIOR |=(ADC_MSK_BIT<<ADTS2) ;
			break;

		case EXTI0_CTC_B :
			SFIOR |=(ADC_MSK_BIT<<ADTS0) ;
			SFIOR |=(ADC_MSK_BIT<<ADTS2) ;
			break;

		case EXTI1_OVF :
			SFIOR |=(ADC_MSK_BIT<<ADTS2) ;
			SFIOR |=(ADC_MSK_BIT<<ADTS1) ;
			break;

		case EXTI1_CAP_EVNT :
			SFIOR |=(ADC_MSK_BIT<<ADTS0) ;
			SFIOR |=(ADC_MSK_BIT<<ADTS1) ;
			SFIOR |=(ADC_MSK_BIT<<ADTS2) ;

			break;

		default:;

		}

		//Enable auto triggering source.
		ADCSRA  |=(ADC_MSK_BIT<<ADATE);

		Local_enuErrorState = ES_OK ;
	}
	else
	{
		Local_enuErrorState =  ES_OUT_OF_RANGE ;
	}

	return Local_enuErrorState   ;

}//End of











/*********************************************************/
/*********************************************************/
/*********************************************************/
ES_t ADC_enuCallBack(volatile void(*Cpy_pfunAppFunc)(void*) ,  void* Cpy_pvidAppPara)
{
	ES_t Local_enuErrorState = ES_NOK ;

	if( Cpy_pfunAppFunc != NULL )
	{
		ADC_pvidfunISRFunc   = Cpy_pfunAppFunc ;

		ADC_pvidISRParameter = Cpy_pvidAppPara ;

		Local_enuErrorState  = ES_OK ;
	}
	else
	{
		Local_enuErrorState = ES_NULL_POINTER  ;
	}
	return Local_enuErrorState   ;
}//End of



