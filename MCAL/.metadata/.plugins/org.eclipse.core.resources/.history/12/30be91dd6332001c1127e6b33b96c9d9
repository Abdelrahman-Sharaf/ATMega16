

ES_t ADC_enuPollingSys(u16* Cpy_pu8Value);
ES_t ADC_enuReadHighValue(u8* Cpy_pu16Value );
ES_t ADC_enuRead(u16* Cpy_pu16Value );
ES_t ADC_enuSelectChannel(u8 Cpy_u8ChannelID );
ES_t ADC_enuEnableTriggeringMode(u8 Cpy_u8TriggingSource);
ES_t ADC_enuDisableTriggeringMode(void);

ES_t ADC_enuEnable(void);
ES_t ADC_enuDisable(void);

ES_t ADC_enuEnableInterruptMode(void);
ES_t ADC_enuDisableInterruptMode(void);


ES_t ADC_enuCallBack( void(*Cpy_pfunAppFunc)(void*) , void* Cpy_pvidAppPara);









/*********************************************************/
/*********************************************************/



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/


/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
ES_t ADC_enuReadHighValue(u8* Cpy_pu8Value )
{
	ES_t Local_enuErrorState = ES_NOK ;

#if      ADC_ADJ   ==   RIGHT_ADJ
	*Cpy_pu8Value = GET_HIGH_BITS_RIGHT_ADJ  ;


#elif    ADC_ADJ   ==   LEFT_ADJ
	*Cpy_pu8Value = ADCH ;

#else
#error "The ADC_ADJ mode that you Chosen is not Valid!!."
#endif

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/



/*********************************************************/
/*********************************************************/


/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
ES_t ADC_enuEnableTriggeringMode(u8 Cpy_u8TriggingSource)
{
	ES_t Local_enuErrorState = ES_NOK ;

	//Disable auto triggering source.
	ADCSRA  &=~(ADC_MSK_BIT<<ADATE);

	SFIOR &=~( (ADC_MSK_BIT<<ADTS2) | ( ADC_MSK_BIT<<ADTS1 ) | (ADC_MSK_BIT<<ADTS0)   );

	switch( Cpy_u8TriggingSource )
	{
	case FREE_RUNNING :
		break;

	case ANALOG_COMPARATOR :
		SFIOR |=(ADC_MSK_BIT<<ADTS0) ;
		break;

	case EXTI0 :
		SFIOR |=(ADC_MSK_BIT<<ADTS1) ;
		break;

	case EXTI0_CTC :
		SFIOR |=(ADC_MSK_BIT<<ADTS0) ;
		SFIOR |=(ADC_MSK_BIT<<ADTS1) ;
		break;

	case EXTI0_OVF :
		SFIOR |=(ADC_MSK_BIT<<ADTS2) ;
		break;

	case EXTI0_CTC_B :
		SFIOR |=(ADC_MSK_BIT<<ADTS0) ;
		SFIOR |=(ADC_MSK_BIT<<ADTS2) ;
		break;

	case EXTI1_OVF :
		SFIOR |=(ADC_MSK_BIT<<ADTS2) ;
		SFIOR |=(ADC_MSK_BIT<<ADTS1) ;
		break;

	case EXTI1_CTC :
		SFIOR |=(ADC_MSK_BIT<<ADTS0) ;
		SFIOR |=(ADC_MSK_BIT<<ADTS1) ;
		SFIOR |=(ADC_MSK_BIT<<ADTS2) ;

		break;

	default:;




	}

	Local_enuErrorState = ES_OK ;

	//Enable auto triggering source.
	ADCSRA  |=(ADC_MSK_BIT<<ADATE);

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
ES_t ADC_enuDisableTriggeringMode(void)
{
	ES_t Local_enuErrorState = ES_NOK ;

	ADCSRA  &=~(ADC_MSK_BIT<<ADATE);

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/

ES_t ADC_enuEnable(void)
{
	ES_t Local_enuErrorState = ES_NOK ;

	ADCSRA  |=(ADC_MSK_BIT<<ADATE);

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/

ES_t ADC_enuDisable(void)
{
	ES_t Local_enuErrorState = ES_NOK ;

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/


ES_t ADC_enuEnableInterruptMode(void)
{
	ES_t Local_enuErrorState = ES_NOK ;

	ADCSRA |=(ADC_MSK_BIT<<ADIE);



	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/

ES_t ADC_enuDisableInterruptMode(void)
{
	ES_t Local_enuErrorState = ES_NOK ;

	ADCSRA &=~(ADC_MSK_BIT<<ADIE);

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/


/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/

ISR(VECT_ADC)
{
	if(ADC_pvidfunISRFunc != NULL )
	{
		(*ADC_pvidfunISRFunc)(ADC_pvidISRParameter);
	}
	else
	{
		//Do nothing.
	}

}

