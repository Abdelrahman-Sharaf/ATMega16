
ES_t ADC_enuStartConversion(void);
ES_t ADC_enuPollingSys(u16* Cpy_pu8Value);
ES_t ADC_enuReadHighValue(u8* Cpy_pu16Value );
ES_t ADC_enuRead(u16* Cpy_pu16Value );
ES_t ADC_enuSelectChannel(u8 Cpy_u8ChannelID );
ES_t ADC_enuEnableTriggeringMode(u8 Cpy_u8TriggingSource);
ES_t ADC_enuDisableTriggeringMode(void);

ES_t ADC_enuEnable(void);
ES_t ADC_enuDisable(void);

ES_t ADC_enuEnableInterruptMode(void);
ES_t ADC_enuDisableInterruptMode(void);


ES_t ADC_enuCallBack( void(*Cpy_pfunAppFunc)(void*) , void* Cpy_pvidAppPara);









/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
ES_t ADC_enuStartConversion(void)
{
	ES_t Local_enuErrorState = ES_NOK ;

	ADCSRA |=(ADC_MSK_BIT<<ADSC);

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
ES_t ADC_enuPollingSys(u16* Cpy_pu8Value)
{
	ES_t Local_enuErrorState = ES_NOK ;


	while( !((ADCSRA>>ADIF)&ADC_MSK_BIT) );

	ADCSRA |=(ADC_MSK_BIT<<ADIF);

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
ES_t ADC_enuReadHighValue(u8* Cpy_pu8Value )
{
	ES_t Local_enuErrorState = ES_NOK ;

#if      ADC_ADJ   ==   RIGHT_ADJ
	*Cpy_pu8Value = GET_HIGH_BITS_RIGHT_ADJ  ;


#elif    ADC_ADJ   ==   LEFT_ADJ
	*Cpy_pu8Value = ADCH ;

#else
#error "The ADC_ADJ mode that you Chosen is not Valid!!."
#endif

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
ES_t ADC_enuRead(u16* Cpy_pu16Value )
{
	ES_t Local_enuErrorState = ES_NOK ;


#if      ADC_ADJ   ==   RIGHT_ADJ
	*Cpy_pu16Value  =  (u16)ADCL  ;
	*Cpy_pu16Value |= ((u16)ADCH<< 8 );


#elif    ADC_ADJ   ==   LEFT_ADJ
	*Cpy_pu16Value  =  ((u16)ADCL>>6)   ;
	*Cpy_pu16Value |=  ((u16)ADCH<<2)   ;

#else
#error "The ADC_ADJ mode that you Chosen is not Valid!!."
#endif




	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
ES_t ADC_enuSelectChannel(u8 Cpy_u8ChannelID )
{
	ES_t Local_enuErrorState = ES_NOK ;

	if( Cpy_u8ChannelID < CHANNEL_7 )
	{
		ADMUX &=~( (ADC_MSK_BIT<<MUX4)|(ADC_MSK_BIT<<MUX3)|(ADC_MSK_BIT<<MUX2)|(ADC_MSK_BIT<<MUX1)|(ADC_MSK_BIT<<MUX0)  );

		ADMUX |= Cpy_u8ChannelID ;

		Local_enuErrorState = ES_OK ;
	}
	else
	{
		Local_enuErrorState = ES_OUT_OF_RANGE ;
	}

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
ES_t ADC_enuEnableTriggeringMode(u8 Cpy_u8TriggingSource)
{
	ES_t Local_enuErrorState = ES_NOK ;

	//Disable auto triggering source.
	ADCSRA  &=~(ADC_MSK_BIT<<ADATE);

	SFIOR &=~( (ADC_MSK_BIT<<ADTS2) | ( ADC_MSK_BIT<<ADTS1 ) | (ADC_MSK_BIT<<ADTS0)   );

	switch( Cpy_u8TriggingSource )
	{
	case FREE_RUNNING :
		break;

	case ANALOG_COMPARATOR :
		SFIOR |=(ADC_MSK_BIT<<ADTS0) ;
		break;

	case EXTI0 :
		SFIOR |=(ADC_MSK_BIT<<ADTS1) ;
		break;

	case EXTI0_CTC :
		SFIOR |=(ADC_MSK_BIT<<ADTS0) ;
		SFIOR |=(ADC_MSK_BIT<<ADTS1) ;
		break;

	case EXTI0_OVF :
		SFIOR |=(ADC_MSK_BIT<<ADTS2) ;
		break;

	case EXTI0_CTC_B :
		SFIOR |=(ADC_MSK_BIT<<ADTS0) ;
		SFIOR |=(ADC_MSK_BIT<<ADTS2) ;
		break;

	case EXTI1_OVF :
		SFIOR |=(ADC_MSK_BIT<<ADTS2) ;
		SFIOR |=(ADC_MSK_BIT<<ADTS1) ;
		break;

	case EXTI1_CTC :
		SFIOR |=(ADC_MSK_BIT<<ADTS0) ;
		SFIOR |=(ADC_MSK_BIT<<ADTS1) ;
		SFIOR |=(ADC_MSK_BIT<<ADTS2) ;

		break;

	default:;




	}

	Local_enuErrorState = ES_OK ;

	//Enable auto triggering source.
	ADCSRA  |=(ADC_MSK_BIT<<ADATE);

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
ES_t ADC_enuDisableTriggeringMode(void)
{
	ES_t Local_enuErrorState = ES_NOK ;

	ADCSRA  &=~(ADC_MSK_BIT<<ADATE);

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/

ES_t ADC_enuEnable(void)
{
	ES_t Local_enuErrorState = ES_NOK ;

	ADCSRA  |=(ADC_MSK_BIT<<ADATE);

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/

ES_t ADC_enuDisable(void)
{
	ES_t Local_enuErrorState = ES_NOK ;

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/


ES_t ADC_enuEnableInterruptMode(void)
{
	ES_t Local_enuErrorState = ES_NOK ;

	ADCSRA |=(ADC_MSK_BIT<<ADIE);



	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/

ES_t ADC_enuDisableInterruptMode(void)
{
	ES_t Local_enuErrorState = ES_NOK ;

	ADCSRA &=~(ADC_MSK_BIT<<ADIE);

	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/



ES_t ADC_enuCallBack(volatile void(*Cpy_pfunAppFunc)(void*) , volatile void* Cpy_pvidAppPara)
{
	ES_t Local_enuErrorState = ES_NOK ;

	if( Cpy_pfunAppFunc != NULL )
	{
		ADC_pvidfunISRFunc   = Cpy_pfunAppFunc ;

		ADC_pvidISRParameter = Cpy_pvidAppPara ;

		Local_enuErrorState  = ES_OK ;
	}
	else
	{
		Local_enuErrorState = ES_NULL_POINTER  ;
	}
	return Local_enuErrorState   ;
}//End of



/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/
/*********************************************************/

ISR(VECT_ADC)
{
	if(ADC_pvidfunISRFunc != NULL )
	{
		(*ADC_pvidfunISRFunc)(ADC_pvidISRParameter);
	}
	else
	{
		//Do nothing.
	}

}

